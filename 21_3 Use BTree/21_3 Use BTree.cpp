
#include <iostream>
#include <conio.h>

#include "BTree.h"  // класс Бинарного дерева по конспекту лекций Step

using namespace std;


int main()
{
	setlocale(LC_ALL, "rus");


	//======================================================================
	//----------------------------------------------------------------------

	/*
	Бинарное дерево (binary tree) — это упорядоченная древовидная
	динамическая структура. Каждый элемент (узел) дерева
	имеет не более двух элементов следующих за ним (потомков)
	и не более одного предыдущего (родителя).
	*/

	/*
	Бинарное (двоичное) дерево поиска – это бинарное дерево,
	для которого выполняются следующие дополнительные условия
	(свойства дерева поиска):

	- оба поддерева – левое и правое, являются двоичными деревьями поиска;
	- у всех узлов левого поддерева произвольного узла X
	значения ключей данных меньше,
	чем значение ключа данных самого узла X;
	- у всех узлов правого поддерева произвольного узла X
	значения ключей данных не меньше, чем значение ключа данных узла X.

	Данные в каждом узле должны обладать ключами,
	для которых определена операция сравнения меньше.
	*/
	

	//======================================================================
	// ДЛЯ САМОСТОЯТЕЛЬНОГО ИЗУЧЕНИЯ: Бинарное дерево, класс BTree
	// (класс описан в конспекте)
	// Заполнение дерева BTree значениями ----------------------------------

	cout << "\nДобавление узлов-------------------------------\n";
	BTree a;
	Node * k = new Node;
	k->x = 20;
	k->left = k->right = k->parent = nullptr;

	a.Insert(k);
	a.Show(a.GetRoot());

	Node *k1 = new Node;
	k1->x = -6;
	k1->left = k1->right = k1->parent = nullptr;

	a.Insert(k1);

	cout << endl;
	a.Show(a.GetRoot());



	//----------------------------------------------------------------------
	//Заполнение дерева BTree значениями элементов массива-----------------

	cout << "\nЗаполнение дерева значениями элементов массива--\n";

	int m[15] = { 9, 0, 17, 3, 1, 15, 6, 7, 10, 11, 4, 13, 12, 14, 5 };
	BTree t;
	Node **mas = new Node *[15];
	for (int i = 0; i < 15; i++)
	{
		mas[i] = new Node;
		mas[i]->left = mas[i]->right = mas[i]->parent = nullptr;
		mas[i]->x = m[i];
		t.Insert(mas[i]);
	}

	t.Show(t.GetRoot());

	cout << "\n-----------------------------------------------\n";



	// ПОИСК ---------------------------------------------------------------

	//Поиск по значению----------------------------------------------------
	int c = 15;
	if (t.Search(c)) cout << "\nЗначение " << c <<"  есть в дереве"<< endl;
	else cout << "\nЗначения "<< c <<"  нет в дереве "<< endl;



	// Поиск по значению от корня с получением адреса узла-----------------
	Node * s = new Node;
	s->left = s->right = s->parent = nullptr;
	s->x = 0;
	



	c = 11;      
	s = t.Search(t.GetRoot(), c);
	if (s) {
		cout << "\nЗначение " << c <<" ("<<mas[9]->x<<")  ("<<s->x<<")   есть в дереве, адрес: " 
			  << mas[9] << " = " << s << endl;
	}else cout << "\nЗначения " << c << "  нет в дереве " << endl;


	   	 


	cout << "\nУдаление---------------------------------------\n";
	Node * sd = new Node;
	sd->x = 0;
	sd->left = sd->right = sd->parent = nullptr;

	int d = 11;        // mas[9]
	sd = t.Search(t.GetRoot(), d);
	if (sd) {
		t.Del(sd);
	}else cout << "\nЗначения " << d << "  нет в дереве " << endl;
	t.Show(t.GetRoot());
	

	


	// Поиск самого "левого" узла----------------------------------------

	cout << "\nПоиск минимального-----------------------------\n";
	Node * smin = new Node;
	smin->x = 0;
	smin->left = s->right = s->parent = nullptr;
	smin = t.Min(t.GetRoot());
	cout << "\nМинимальное значение: " << smin->x << endl;
	t.Show(smin);   // выводится от минимума до вершины(не включая)



	// Поиск самого "правого" узла---------------------------------------

	cout << "\nПоиск максимального----------------------------\n";
	s = new Node;
	s->left = s->right = s->parent = nullptr;
	s = t.Max(t.GetRoot());
	cout << "\nМаксимальное значение: " << s->x << endl;
	t.Show(s);// выводится от вершины(не включая) до максимума


	// Поиск следующего узла--------------------------------------------

	cout << "\nЗначение следующего узла ----------------------\n";
	Node * nt = new Node;

	nt = t.Next(t.GetRoot());
	cout << "\nТекщее значение: " << t.GetRoot()->x << endl;
	cout << "\nСледующее значение: " << nt->x << endl;

	nt = t.Next(mas[12]);
	if (nt) {
	cout << "\nТекщее значение: " << mas[12]->x << endl;
	cout << "\nСледующее значение: " << nt->x << endl;
	}
	else cout << "\nError";


	cout << "\nОчищение всего списка --------------------------\n";
	t.Del();
	t.Show(t.GetRoot());


	_getch();
	return 0;

}

