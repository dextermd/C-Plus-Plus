/*
Игра "Крепс"

Игрок бросает две кости.
Каждая кость имеет шесть граней (значения от 1 до 6).
После броска вычисляется сумма двух верхних граней
(реализовать в виде функции, которая генерирует значения
двух выпавших костей от 1 до 6, выводит на экран и
возвращает сумму).

- Если после первого броска сумма равна 7 или 11, игрок выиграл.

- Если после первого броска сумма равна 2, 3 или 12 (это называется "крепс"),
игрок проигрывает.

- Если после первого броска сумма равна 4, 5, 6, 8, 9 или 10,
то эта сумма становится очками игрока.

Чтобы выиграть, игрок должен продолжать бросать кости до тех пор,
пока не выпадет сумма, равная его очкам.

Игрок проигрывает, если во время этих бросков ему выпадает сумма 7.
*/

//----------------------------------------------------------
/*
Определенный пользователем тип, называемый перечислимым (enumeration),
вводится ключевым словом enum перед именем типа
и является набором целых именованных констант, п
редставленных своими идентификаторами.

Если не указано начальное значение, то оно равно 0
и увеличивается последовательно на 1.
*/


#include <iostream>
#include <conio.h>
#include <time.h>

using namespace std;


int Trow();

int game()
{
	setlocale(LC_ALL, "rus");

	srand(time(nullptr));

	enum status { WON, LOST, CONTINUE };
	int s;

	status game;
	s = Trow();           // первый бросок костей

	switch (s)
	{
		// выигрыш после первого броска
	case 7: case 11: game = WON; break;
		// проигрыш после первого броска
	case 2: case 3: case 12: game = LOST; break;
		// запоминание очков
	default: game = CONTINUE;
		cout << "Ваши очки " << s << endl;
	}

	while (game == CONTINUE)  // бросать дальше
	{
		int st = Trow();
		if (st == s) game = WON;// выигрыш по очкам
		if (st == 7) game = LOST;// проигрыш после суммы 7
	}
	if (game == WON) cout << "Победа!!!";
	else cout << "Увы . . .";


	_getch();
	return 0;
}
//---------------------
int Trow()
{
	int k1 = rand() % 6 + 1;
	int k2 = rand() % 6 + 1;
	cout << "Выпало: " << k1 << ":" << k2
		<< " сумма " << (k1 + k2) << endl;
	return (k1 + k2);
}