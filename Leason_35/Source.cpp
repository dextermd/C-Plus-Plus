#include <iostream>
#include <stdlib.h>
#include <conio.h>
#include <iomanip>
#include <Windows.h>
#include <string.h>
#include <algorithm>
#include "Data.h"
#include "Student.h"
#include "my_templates.h"


using namespace std;


int main()
{

#if 0

    // -------------------------------------------------------------------------------- \\
    // Динамическое выделение памяти в Си ---------------------------------------------
    // malloc

    int* a = new int;
    if (a)
    {
        *a = 20;
        cout << *a;
        delete a;
        a = nullptr;
    }

    printf("\n");

    int* b = (int*)malloc(sizeof(int));
    if (b)
    {
        *b = 78;
        printf("%d", *b); // cout << *b;

        free(b);  // delete b;
        b = nullptr;
    }


#endif

    // --------------------------------------------------------------------------------------------------------------------------- \\

#if 0
    
    // Выделение памяти под одномерный динамический массив -----------------------------------------------------------------------
    // malloc - принимает размер необходимой памяти в байтах ---------------------------------------------------------------------
    // Нет обнуления значений по умолчанию ---------------------------------------------------------------------------------------

    int size;
    printf("\nВведите кол-во элементов массива: ");
    scanf_s("%d", &size);

    int* mas = (int *)malloc(size * sizeof(int));
    if (mas)
    {
        printf("\nАдрес: %p\n", mas);

        for (int i = 0; i < size; i++)
        {
            printf("%d  ", mas[i]);
        }

        printf("\n\n");

        for (int i = 0; i < size; i++)
        {
            mas[i] = rand() % 21 - 10;
            printf("%d  ", mas[i]);
        }

        free(mas);
        printf("\nАдрес: %p\n", mas);
        mas = nullptr;
        printf("\nАдрес: %p\n", mas);
    }

#endif


    // --------------------------------------------------------------------------------------------------------------------------- \\

#if 0

    // Самостоятельно:
    // Создать динамическую матрицу дробных чисел
    // в диапазоне от 0.4 до 4.00
    //  ...(rand() % 10 + 1) / 2.5

    int row, col;
    printf("\nВведите кол-во элементов массива: ");
    scanf_s("%d %d", &row, &col);
    printf("\n");

    double** mas = (double**)malloc(row * sizeof(double*));

    if (mas)
    {
        for (int i = 0; i < row; i++)
        {
            mas[i] = (double*)malloc(col * sizeof(double));
            if (mas[i])
            {
                for (int j = 0; j < col; j++)
                {
                    mas[i][j] = (rand() % 10 + 1) / 2.5;
                    printf("%6.2lf ", mas[i][j]);
                }
                printf("\n");
            }
        }

        for (int i = 0; i < row; i++)
        {
            free(mas[i]);
        }

        free(mas);
        mas = nullptr;

    }

#endif

    // --------------------------------------------------------------------------------------------------------------------------- \\

#if 0

    // Выделение памяти под одномерный динамический массив
    // calloc
    // аналогично malloc, но два параметра (количество элементов
    // и размер под каждый элемент) , значения обнуляются

    int size;
    printf("\nВведите кол-во элементов массива: ");
    scanf_s("%d", &size);

    int* m = (int*)calloc(size, sizeof(int));
    if (m)
    {
        for (int i = 0; i < size; i++)
        {
            printf("%d ", m[i]);
        }

        printf("\n");

        for (int i = 0; i < size; i++)
        {
            m[i] = rand() % 5;
            printf("%d ", m[i]);
        }

        free(m);
        m = nullptr;
    }

#endif


    // --------------------------------------------------------------------------------------------------------------------------- \\

#if 0

    // realloc
    
    // Перераспределение блоков памяти, 
    // выделенных malloc или calloc
    // Исходные значения сохраняются. 
    // Блок памяти может уменьшаться или увеличиваться в размере

    int size;
    printf("\nВведите кол-во элементов массива: ");
    scanf_s("%d", &size);

    int* m = (int*)calloc(size, sizeof(int));
    if (m)
    {
        for (int i = 0; i < size; i++)
        {
            printf("%d ", m[i]);
        }

        printf("\n");

        for (int i = 0; i < size; i++)
        {
            m[i] = rand() % 5;
            printf("%d ", m[i]);
        }
    }

    int size2;
    printf("\nВведите новый размер массива: ");
    scanf_s("%d", &size2);

    int* copy = m; // Копия адреса
    m = (int *)realloc(m, size2 * sizeof(int));
    if (m)
    {
        for (int i = 0; i < size2; i++)
        {
            printf("%d ", m[i]);
        }

        printf("\n");

        for (int i = size; i < size2; i++)
        {
            m[i] = rand() % 6 - 10; // от -10 до -5
        }


        for (int i = 0; i < size2; i++)
        {
            printf("%d ", m[i]);
        }

        free(m);
        m = nullptr;
    }
    else {
        printf("\nОшибка");
        free(copy);
        copy = nullptr;
    }

#endif


    // --------------------------------------------------------------------------------------------------------------------------- \\

#if 0

    // Арифметические оперции в двоичной системе исчисления


    int a = 25, b = 5, c;
    char str[32];

    c = a + b;

    _itoa_s(a, str, 2);
    cout << setw(8) << str << endl;

    _itoa_s(b, str, 2);
    cout << setw(8) << str << endl;

    _itoa_s(c, str, 2);
    cout << setw(8) << str << endl;

#endif

    // --------------------------------------------------------------------------------------------------------------------------- \\

#if 0

    // Операция СДВИГ ВЛЕВО << 

    /*
    
    Поразрядная операция «сдвиг влево»  переносит содержимое каждого разряда
    первого операнда на то количество разрядов влево,
    которое задано вторым операндом,
    освобождающиеся разряды справа заполняются нулями.
    Результат операции содержит сдвинутое машинное слово,
    а сами операнды не изменяется.

 

    Сдвиг влево на n разрядов интерпретируется как
    целочисленное умножение на 2 в степени n

    */
  
    int a = 25, c;
    char str[32];

    _itoa_s(a, str, 2);
    cout << setw(8) << str << endl;

    c = a << 3;

    _itoa_s(c, str, 2);
    cout << setw(8) << str << endl;

    cout << "\c = " << c << endl;

    cout << (a << 3) << " = " << a * pow(2, 3);

    // Возведение двойки в степень

    int s, res;
    cout << "\nВведите степень двойки: ";
    cin >> s;

    res = 1 << s;

    cout << "\nres = " <<  res;

    /*
    
    Поразрядная операция «сдвиг вправо»  имеет некоторые особенности выполнения.
    По аналогии со сдвигом влево операция сдвига вправо
    на n разрядов интерпретируется
    как целочисленное деление на 2 в степени n.

 

    При этом заполнение освобождающихся старших разрядов
    производится таким образом,
    чтобы сдвиг соответствовал операции деления
    с учетом формы представления целого.

 

    Для беззнакового целого заполнение должно производиться нулями(логический сдвиг),
    а для целого со знаком - сопровождаться дублированием значения старшего знакового разряда
    (арифметический сдвиг).
    В последнем случае отрицательное число при сдвиге останется отрицательным.


    */

    

#endif

    // --------------------------------------------------------------------------------------------------------------------------- \\

#if 0

    // Операция СДВИГ ВПРАВО << 

    /*

    Поразрядная операция «сдвиг вправо»  имеет некоторые особенности выполнения.
    По аналогии со сдвигом влево операция сдвига вправо
    на n разрядов интерпретируется
    как целочисленное деление на 2 в степени n.

 

    При этом заполнение освобождающихся старших разрядов
    производится таким образом,
    чтобы сдвиг соответствовал операции деления
    с учетом формы представления целого.

 

    Для беззнакового целого заполнение должно производиться нулями(логический сдвиг),
    а для целого со знаком - сопровождаться дублированием значения старшего знакового разряда
    (арифметический сдвиг).
    В последнем случае отрицательное число при сдвиге останется отрицательным.


    */


    int a = 25, c, k;
    char str[32];

    cout << "\nВведите величину сдвига: ";
    cin >> k;

    _itoa_s(a, str, 2);
    cout << setw(8) << str << endl;

    c = a >> k;

    _itoa_s(c, str, 2);
    cout << setw(8) << str << endl;

    cout << "\c = " << c << endl;

    cout << (a << k) << " = " << a * pow(2, k);




#endif

    // --------------------------------------------------------------------------------------------------------------------------- \\

#if 1

    // Логическая операция & "И"

    /*
    По отношению ко второму операнду( маске ) логическая операция "И"
    сохраняет (выделяет) те разряды первого операнда,
    которые соответствуют единичным разрядам маски,
    и сбрасывает в 0 разряды результата,
    которые соответствуют в маске заполнены нулями.

 

    Операция так и называется -  выделение разрядов по маске.

 

    x x x x x x x x  - операнд
    0 0 1 1 1 0 0 0  - маска
    0 0 x x x 0 0 0  - результат

 

    Маска – это константа, с определенной расстановкой единичных и нулевых  разрядов
    */

    // Пример:  Проверить, установлен ли бит

    int a = 25, m = 8,b, c;
    char str[32];

    cout << "\nВведи номер бита от 0 до 31: ";
    cin >> b;

    m = 1 << b;

    c = a & m;

    if (a & m)
    {
        cout << "\bБит " << b <<" установлен" << endl;
    }
    else {
        cout << "\bБит " << b << " не установлен" << endl;
    }

    _itoa_s(a, str, 2);
    cout << setw(8) << str << endl;

    _itoa_s(m, str, 2);
    cout << setw(8) << str << endl;

    _itoa_s(c, str, 2);
    cout << setw(8) << str << endl;

    cout << "\nc = " << c << endl;

    // Пример: Выделить разряды с 4 по 7

    int g = 171, r;
    int maska = 240; // 1111 0000   0xF0
    char str2[32];

    // r = a & m;
    r = g & 0xF0;

    _itoa_s(g, str2, 2);
    cout << setw(8) << str2 << endl;

    _itoa_s(maska, str2, 2);
    cout << setw(8) << str2 << endl;

    _itoa_s(r, str2, 2);
    cout << setw(8) << str2 << endl;

    cout << "\nr = " << r << endl;
    r = r >> 4;

    _itoa_s(r, str2, 2);
    cout << setw(8) << str2 << endl;
    cout << "\nr = " << r << endl;


#endif

    _getch();
}