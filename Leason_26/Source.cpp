#include <iostream>
#include <stdlib.h>
#include <conio.h>
#include <iomanip>
#include <Windows.h>
#include "array_functions.h"
#include "help_functions.h"
#include "my_template.h"
#include "color.h"
#include "dynamic_arr.h"


using namespace std;


int main()
{

    //setlocale(LC_ALL, "rus");

    // ---------------------------------------------------------------------------------------------------------------- //
    // **************************************** Динамическое выделение памяти ***************************************** //
    /*
        Дан динамический одномерный массив, размер вводится с клавиатуры.
        Необходимо на его основе создать новый динамический
        массив(минимального размера),
        в котором не будет четных значений.
    */
 
#if 0

    int size;
    cout << "\nВведите размер массива: ";
    cin >> size;

    int* m = memory(size);
    if (m)
    {
        cout << "\n m = " << m << endl;
        init(m, size, -5, 20);
        showDynamArr(m, size);

        int count_odd = 0;
        for (int i = 0; i < size; i++)
        {
            // if (*(m + i) % 2) // проверка числа на нечетность 
            if(m[i] % 2)
            {
                count_odd++;
            }
        }

        cout << "\nКоличество нечетных: " << count_odd << endl;

        // Выделение памяти под новый массив нечетных значений
        int* odd = new int[count_odd];
        if (odd)
        {
            int k = 0;
            // Копируем нечетные значения в новый массив
            for (int i = 0; i < size; i++)
            {
                if (m[i] % 2)
                {
                    odd[k++] = m[i];
                    //k++;
                }
            }

            cout << "\n odd = " << odd << endl;
            cout << "\nМассив нечетных значений: \n";
            showDynamArr(odd, count_odd);
            destroy(odd);
        }

        destroy(m);
        cout << "\n m = " << m << endl;
    }
    else {
        cout << "\nОшибка выделения памяти";
    }

#endif

    // ---------------------------------------------------------------------------------------------------------------- //
    // **************************************** Динамическое выделение памяти ***************************************** //
    /*
    Написать функцию, которая принимает одномерный  массив целых
    (можно передавать либо статический массив либо динамический),
    его размер    и на основе него формирует новый массив, в котором нет нечетных.
    Вернуть адрес нового массива.     В качестве третьего параметра передается по ссылке переменная
    для получения размера результирующего массива.
    */

#if 0

    int size;
    cout << "\nВведите размер массива: ";
    cin >> size;

    int* m = memory(size);
    if (m)
    {
        cout << "\n m = " << m << endl;
        init(m, size, -5, 20);
        showDynamArr(m, size);

        // ...
        // Вызов функции, которая возвращает адрес нового массива

        int s2; // размер нового массива
        int* res = mas_odd(m, size, s2);

        if (res)
        {
            cout << "\nres = " << res << endl;
            cout << "\nРазмер нового массива: " << s2 << endl;
            cout << "\nНовый массива: \n";

            showDynamArr(res, s2);
            destroy(res);
            
        }
        destroy(m);
    }
    else {
        cout << "\nОшибка выделения памяти";
    }

#endif

    // ---------------------------------------------------------------------------------------------------------------- //
    // **************************************** Динамическое выделение памяти ***************************************** //
    /*
        Прототип: int * push_back(int *m, int s, int value);     
        Написать функцию, которая принимает одномерный массив целых,
        размер массива и добавляемое целое значение.
        Функция должна сформировать новый массив,
        добавив элемент в конец исходного массива
        и вернуть указатель на новый динамический массив.
    */
#if 0

    int size;
    cout << "\nВведите размер массива: ";
    cin >> size;

    int* m = memory(size);
    if (m)
    {
        cout << "\n m = " << m << endl;
        init(m, size, -5, 20);
        showDynamArr(m, size);
        // ...
        int s2;
        int* r = push_back(m, size, s2, 500);
        if (r)
        {
            cout << "\n r = " << r << endl;
            cout << "\nРазмер нового массива: " << s2 << endl;
            showDynamArr(r, s2);

            destroy(r);
        }
        

        destroy(m);
        cout << "\n m = " << m << endl;
    }
    else {
        cout << "\nОшибка выделения памяти";
    }

#endif


    // ---------------------------------------------------------------------------------------------------------------- //
    // **************************************** Динамическое выделение памяти ***************************************** //
    /*
        Прототип: int * push_back(int *m, int s, int value);    
        Написать функцию, которая принимает одномерный массив целых,
        размер массива и добавляемое целое значение.
        Функция должна сформировать новый массив,
        добавив элемент в начало исходного массива
        и вернуть указатель на новый динамический массив.
    */
#if 0

    int size;
    cout << "\nВведите размер массива: ";
    cin >> size;

    int* m = memory(size);
    if (m)
    {
        cout << "\n m = " << m << endl;
        init(m, size, -5, 20);
        showDynamArr(m, size);
        // ...
        int s2;
        int* r = push_start(m, size, s2, 500);
        if (r)
        {
            cout << "\n r = " << r << endl;
            cout << "\nРазмер нового массива: " << s2 << endl;
            showDynamArr(r, s2);

            destroy(r);
        }


        destroy(m);
        cout << "\n m = " << m << endl;
    }
    else {
        cout << "\nОшибка выделения памяти";
    }

#endif


    // ---------------------------------------------------------------------------------------------------------------- //
    // **************************************** Динамическое выделение памяти ***************************************** //
    /*
    Написать функцию, которая принимает одномерный  динамический
    массив целых  его размер и удаляет из него четные значения,
    меняет размер исходного массива.
    */
#if 0
    int size;
    cout << "\nВведите размер массива: ";
    cin >> size;

    int* m = memory(size);
    if (m)
    {
        cout << "\n m = " << m << endl;
        init(m, size, -5, 20);
        cout << "\nРазмер  массива: " << size << endl;
        showDynamArr(m, size);
        // ...
        mas_odd(m, size);
        cout << "\nРазмер нового массива: " << size << endl;
        showDynamArr(m, size);

        destroy(m);
        cout << "\n m = " << m << endl;
    }
    else {
        cout << "\nОшибка выделения памяти";
    }

#endif

    // ---------------------------------------------------------------------------------------------------------------- //
    // **************************************** Динамическое выделение памяти ***************************************** //

    /*
    Прототип: void push_back(int *&m, int &size, int value);     
    Написать функцию, которая принимает массив, размер массива,
    добавляемое значение.
    Функция должна добавить элемент в конец исходного массива
    и изменить его размер.    
    */

#if 0

    int size;
    cout << "\nВведите размер массива: ";
    cin >> size;

    int* m = memory(size);
    if (m)
    {
        cout << "\n m = " << m << endl;
        init(m, size, -5, 20);
        showDynamArr(m, size);

        // ...
  
        push_back(m, size, 500);
        showDynamArr(m, size);

        destroy(m);
    }
    else {
        cout << "\nОшибка выделения памяти";
    }

#endif


    // ---------------------------------------------------------------------------------------------------------------- //
    // **************************************** Динамическое выделение памяти ***************************************** //
    /*
    Написать функцию добавления элемента в динамический
    массив по индексу. Исходный массив и его размер меняются.
    */

#if 0

    int size;
    cout << "\nВведите размер массива: ";
    cin >> size;

    int* m = memory(size);
    if (m)
    {
        cout << "\n m = " << m << endl;
        init(m, size, -5, 20);
        showDynamArr(m, size);

        // ...
        int idx = 3, value = 500;
        if (idx >= 0 && idx <= size)
        {
            add_by_index(m, size, idx, value);
            showDynamArr(m, size);
            destroy(m);
        }
        else {
            cout << "\nНеверный индекс";
        }
    }
    else {
        cout << "\nОшибка выделения памяти";
    }

#endif


    // ---------------------------------------------------------------------------------------------------------------- //
    // ************************************* Динамическое выделение памяти МАТРИЦА ************************************ //
    // Создание двумерного массива динамически

#if 0

    int row, col;
    cout << "\nВведи количество строк, колонок: ";
    cin >> row >> col;

    // Выделение памяти под одномерный массив адресов (тип указатель) строк матрицы ( кол-во телефонов  по которым надо позвонить и записать информацию )
    int** arr = new int* [row];

    if (arr)
    {
        // Выделение памяти под каждую строку матрицы (под одномерный массив)
        for (int i = 0; i < row; i++)
        {
            arr[i] = new int [col];
        }

        // Инициализация значений матрицы
        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                arr[i][j] = rand() % 21 - 10;
                cout << setw(6) << arr[i][j];
            }
            cout << endl;
        }
        
        // Освобождение памяти
        // Освобождение памяти, выделение под строки матрицы
        for (int i = 0; i < row; i++)
        {
            delete[]arr[i];
        }
        delete[]arr;
    }

#endif

    //--------------------------------------------------------------------------
    // Создание двумерного массива динамически

#if 0
    int row, col;
    cout << "\nВведи количество строк, колонок: ";
    cin >> row >> col;

    // Выделение памяти под одномерный массив адресов(=указателей) строк матрицы
    int** mas = new int* [row];

    if (mas)
    {
        // Выделение памяти под каждую строку матрицы(=под одномерный массив)
        for (int i = 0; i < row; i++)
        {
            mas[i] = new int[col];
        }

        //Инициализация значений матрицы и вывод на экран
        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                mas[i][j] = rand() % 21 - 10;
                cout << setw(6) << mas[i][j];
            }
            cout << endl;
        }

        //Освобождение памяти:
        // Освобождаем память, выделенную под строки матрицы
        for (int i = 0; i < row; i++) {
            delete[]mas[i];
        }
        // Освобождаем память, выделенную под адреса строк
        delete[]mas;
    }


#endif // 1

    //--------------------------------------------------------------------------
    /*
    Написать функции для:
    - создания динамической матрицы
    - инициализации элементов матрицы
    - вывода матрицы на экран
    - освобождения памяти
    */

#if 1
    int row, col;
    cout << "\nВведи количество строк, колонок: ";
    cin >> row >> col;

    int** res = memory(row, col);
    if (res)
    {
        init(res, row, col, -20, 20);
        show(res, row, col);
        destroy(res, row);
    }



#endif // 1

    _getch();
}


//===============================================================
/*
Способы инициализации указателя:

1.	Присваивание указателю адреса существующего объекта :
­	- с помощью операции получения адреса : int a = 5; int* p = &a;
­	- значением другого инициализированного указателя : int* r = p;
­	- именем массива или функции, которые трактуются как адрес : int b[10];  int* t = b;
­	- адресом функции : void f(int a) {  }  void (*pf)(int);	pf = f;

2.	Присваивание указателю адреса области памяти в явном виде :
    char* vp = (char*)0xB8000000;

3.	Присваивание пустого значения : int* suxx = nullptr; int* rulez = 0;

4.	Выделение участка динамической памяти и присваивание ее адреса указателю : с помощью операции new :
    int* n = new int; Освобождение памяти при этом осуществляется операцией delete n; .

*/
