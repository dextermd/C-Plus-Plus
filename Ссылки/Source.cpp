#include <iostream>
#include <stdlib.h>
#include <conio.h>
#include <iomanip>
#include <Windows.h>

using namespace std;

void change(int a, int b) 
{
    int t;
    t = a;
    a = b;
    b = t;
    cout << "\nФункция Адрес а: " << &a << endl;
}

// void change(int &a, int &b) // Перезагрузку функции нельзя делать если отличия только в передаче параметров по ссылке
void change_new(int &a, int &b)
{
    int t;
    t = a;
    a = b;
    b = t;
    cout << "\n****Функция Адрес а: " << &a << endl;
    cout << "\n****Функция а: " << a << " b: " << b << endl;
}

int math_operation(int a, int b, int & sub, double &divide, double &mult)
{
    int summa;
    summa = a + b;
    sub = a - b;
    divide = (double)a / b;
    mult = (double)a * b;
    return summa;
}


void count_even_odd(int m[], int size, int & even, int & odd)
{
    even = 0;
    odd = 0;

    for (int i = 0; i < size; i++)
    {
        if (m[i] % 2 == 0)
        {
            even++;
        }
        else {
            odd++;
        }
    }
}


int& maximum(int arr[], int size)
{
    int index_max = 0; // Пусть первый элемент максимальный массива мах ( индекс = 0)
    for (int i = 0; i < size; i++)
    {
        if (arr[i] > arr[index_max])
        {
            index_max = i;
        }
    }
    return arr[index_max];
}



int main()
{

    //setlocale(LC_ALL, "rus");

    // ---------------------------------------------------------------------------------------------------------------- //
    // ****************************************** Ссылки  (reference) ************************************************* //
    /*
    Независимые ссылки:
    - при объявлении необходимо сразу инициализировать
    - не выделяется память
    - нельзя создавать массивы ссылок
    */
    // ---------------------------------------------------------------------------------------------------------------- //

    //system("color 1F");

    //// Независимые ссылки
    //int x = 25;

    //cout << "\nЗначение " << x << endl;
    //cout << "\nАдрес " << &x << endl;

    //int& ref = x; // Обьявили и  одновременная(!) инициалтзация ссылку на значение целого типа

    //cout << "\nЗначение " << ref << endl;
    //cout << "\nАдрес " << &ref << endl;
    //ref = 100;

    //int& ref2 = x;

    //cout << "\nЗначение " << ref2 << endl;
    //cout << "\nАдрес " << &ref2 << endl;

    // ---------------------------------------------------------------------------------------------------------------- //
    // Написать функцию, которая принимает две целые переменные и
    // обменивает их значениями
    // ---------------------------------------------------------------------------------------------------------------- //

    // 1. Когда надо работать напрямую с фактическими параметрами, change_new

    //int a = 25, b = -10;
    //cout << "\nАдрес а: " << &a << endl;
    //cout << a << "  " << b << endl;

    //cout << "\nПопытка обменять значения a и b через функцию без ссылок - НЕ РАБОТАЕТ !!!!";
    //change(a, b);
    //cout << a << "  " << b << endl;

    //cout << "\nПопытка обменять значения a и b через функцию с ссылок - РАБОТАЕТ !!!";
    //change_new(a, b);
    //cout << a << "  " << b << endl;


    // ---------------------------------------------------------------------------------------------------------------- //
    // 2. При передаче обьекта структуры или класса, т.е. Обьектов, под  которые выделяются больше памяти;




    // ---------------------------------------------------------------------------------------------------------------- //
    // 3. Ссылка - как параметр функции;  (****** Возврат нескольких значений из функции *******)
    // Функция, которая возвращает результат четырех арифметических операций
    // для передаваемых параметров: сумму, произведение, деление(результат дробный)
    // и вычитание.

    //int a = 10, b = 6, summa, minus;
    //double divide, mult;
    //
    //summa = math_operation(a, b, minus, divide, mult);

    //cout << "\nСумма : " << summa;
    //cout << "\nВычитание : " << minus;
    //cout << "\nУмножение : " << mult;
    //cout << "\nДеление : " << divide;


    // Ссылки, как параметр функции и результат работы     
    /*Написать функцию, которая принимает массив
    и возвращает кол - во четных и нечетных значений*/

    //const int  N = 10;
    //int arr[N];

    //for (int i = 0; i < N; i++)
    //{
    //    arr[i] = rand() % 21 - 10;
    //    cout << arr[i] << "  ";
    //}

    //int chet, nechet;

    //count_even_odd(arr, N, chet, nechet);

    //cout << "\nКоличество четных значений массива: " << chet;
    //cout << "\nКоличество не четных значений массива: " << nechet;



    // ---------------------------------------------------------------------------------------------------------------- //
    // 4. - тип возвращаемого значения
    
    /*Когда использовать возврат по ссылке :
        -при возврате ссылки - параметра;
        -при возврате элемента массива, который был передан в функцию;
        -при возврате большой структуры или класса, который не уничтожается в конце функции 
        (например, тот, который был передан в функцию).Когда не использовать возврат по ссылке :
        -при возврате переменных, которые были объявлены внутри функции(используйте возврат по значению);
        -при возврате стандартного массива или значения указателя(используйте возврат по адресу).*/

    // Замена значения максимального элемента массива нулем

    const int  N = 10;
    int arr[N];

    for (int i = 0; i < N; i++)
    {
        arr[i] = rand() % 51 - 10;
        cout << arr[i] << "  ";
    }

    cout << "\nМаксимальное значение массива: " << maximum(arr, N) << endl;

    maximum(arr, N) = 0;

    for (int i = 0; i < N; i++)
    {
        cout << arr[i] << "  ";
    }











    _getch();
}
